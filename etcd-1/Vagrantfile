#
# *** etcd
# Create etcd nodes and M clients.
#

VAGRANTFILE_API_VERSION = "2"
# set docker as the default provider
ENV['VAGRANT_DEFAULT_PROVIDER'] = 'docker'
# disable parallellism so that the containers come up in order
ENV['VAGRANT_NO_PARALLEL'] = "1"
ENV['FORWARD_DOCKER_PORTS'] = "1"
# minor hack enabling to run the image and configuration trigger just once
ENV['VAGRANT_EXPERIMENTAL']="typed_triggers"

unless Vagrant.has_plugin?("vagrant-docker-compose")
  system("vagrant plugin install vagrant-docker-compose")
  puts "Dependencies installed, please try the command again."
  exit
end

# Names of Docker images built:
ETCD_IMAGE  = "etcd-1/etcdnode:0.1"
CLIENT_IMAGE   = "etcd-1/client:0.1"

# Subnet to use:
SUBNET = "10.0.1."

# Node definitions
ETCDNODE = { :nameprefix => "etcd-",
             :subnet => SUBNET,
             :ip_offset => 10, 
             :image => ETCD_IMAGE
          }
CLIENT  = { :nameprefix => "client-",
            :subnet => SUBNET,
            :ip_offset => 100,
            :image => CLIENT_IMAGE,
            :config => "client/client.cfg"
          }
# Number of etcd nodes to start:
ETCD_COUNT = 3 # this should be an odd number
# Number of clients to start:
CLIENTS_COUNT = 1

etcd_cluster = ""
zoo_client_hosts = ""
project_dir = Dir.pwd

# Common configuration
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  # Before the 'vagrant up' command is started, build docker images:
  config.trigger.before :up, type: :command do |trigger|
    trigger.name = "Build docker images and configuration files"
    trigger.ruby do |env, machine|
        # --- start of Ruby script ---
        # Build etcd node list:
        puts "Building etcd configuration."
        etcd_nodes = []
        zoo_hosts = []
        (1..ETCD_COUNT).each do |i|
            etcd_nodes << "#{ETCDNODE[:nameprefix]}#{i}=http://#{ETCDNODE[:subnet]}#{ETCDNODE[:ip_offset] + i}:2380"
#            zoo_ensemble << "server.#{i}=#{ZOONODE[:subnet]}#{ZOONODE[:ip_offset] + i}:2888:3888;2181"
#            zoo_hosts << "#{ZOONODE[:subnet]}#{ZOONODE[:ip_offset] + i}:2181"
        end
        etcd_cluster = etcd_nodes.join(",")
        puts "etcd_cluster: #{etcd_cluster}"
        # # Build etcd image:
        # puts "Building etcd image:"
        # `docker build etcd -t "#{ETCD_IMAGE}"`
        # # Build client node image:
        # puts "Building client node image:"
        # `docker build client -t "#{CLIENT_IMAGE}"`
        # --- end of Ruby script ---
    end
  end

  config.ssh.insert_key = false

  # Definition of N etcd nodes
  (1..ETCD_COUNT).each do |i|
    node_ip_addr = "#{ETCDNODE[:subnet]}#{ETCDNODE[:ip_offset] + i}"
    node_name = "#{ETCDNODE[:nameprefix]}#{i}"
    # Definition of etcd node
    config.vm.define node_name do |s|
      s.vm.network "private_network", ip: node_ip_addr
      s.vm.hostname = node_name 
      s.vm.provider "docker" do |d|
        #d.image = ETCDNODE[:image]
        d.build_dir = "etcd"
        d.name = node_name
        d.has_ssh = false
        d.env = { "NODE_NAME" => node_name, "NODE_IP" => node_ip_addr, "CLUSTER" => etcd_cluster }
        #d.create_args = [ "--mount", "src=#{project_dir}/client/python,target=/opt/client,type=bind" ]
      end
      s.vm.post_up_message = "Node #{node_name} up and running. You can access the node with 'vagrant ssh #{node_name}'}"
    end
  end

  # # Definition of N client nodes
  # (1..CLIENTS_COUNT).each do |i|
  #   node_ip_addr = "#{CLIENT[:subnet]}#{CLIENT[:ip_offset] + i}"
  #   node_name = "#{CLIENT[:nameprefix]}#{i}"
  #   # Definition of client node
  #   config.vm.define node_name do |s|
  #     s.vm.network "private_network", ip: node_ip_addr
  #     s.vm.hostname = node_name
  #     s.vm.provider "docker" do |d|
  #       d.image = CLIENT[:image]
  #       d.name = node_name
  #       d.has_ssh = true
  #       d.env = { "ZOO_SERVERS" => "#{zoo_client_hosts}" }
  #     end
  #     s.vm.post_up_message = "Node #{node_name} up and running. You can access the node with 'vagrant ssh #{node_name}'}"
  #   end
  # end

end

# EOF
